master = na.omit(master)
master = subset(master, p != 0)
#Sort master by p-value
sorted_p.adj=order(master[,"p.adj"], decreasing=FALSE)
master=master[sorted_p.adj,]
#Make a new column in master table for mean expression
master$em_mean=rowMeans(master[,as.vector(ss$SAMPLE)])
#Add a column for -log10p to the master table
master$mlog10p=-log10(master$p)
## Exporting many items in a list
master_list = list(profile=profile_names,
master_table=master)
#return master
return(master_list)
}
master_maker = function(profile_names,de,em_annotated,de,ss){
## Creating master tables
# merge: em_annotated - de
master = merge(em_annotated, de, by.x = 1, by.y = 0)
#rename row.names to "Emsembl_IDs"
names(master)[1] = "Emsembl_IDs"
#make "gene" names.row
row.names(master) = master[,"gene"]
#Remove rows from master table that have N.A.s
master = na.omit(master)
master = subset(master, p != 0)
#Sort master by p-value
sorted_p.adj=order(master[,"p.adj"], decreasing=FALSE)
master=master[sorted_p.adj,]
#Make a new column in master table for mean expression
master$em_mean=rowMeans(master[,as.vector(ss$SAMPLE)])
#Add a column for -log10p to the master table
master$mlog10p=-log10(master$p)
## Exporting many items in a list
master_list = list(profile=profile_names,
master_table=master)
#return master
return(master_list)
}
master_senes_vs_prolif = master_maker("senes_vs_prolif", DE_Senes_vs_Prolif, em_annotated, ss)
View(master_senes_mtd_vs_senes)
View(em_annotated)
####################### FUNCTION: EM MAKER #####################################
# output: em_annotated, em_symols, em_scaled
em_maker = function(em, annotations, ss){
#change the names of the annotations columns
names(annotations) = c("gene", "chromosome","start","stop","biotype")
# first merge:  em-annotations
em_annotated= merge(em, annotations, by.x=0, by.y=0)
names(em_annotated)[1] = "Ensembl_ID"
row.names(em_annotated) = em_annotated[,"gene"]
#generate expression matrix table with "gene" as BOLD row
em_symbols=em_annotated[,as.vector(ss$SAMPLE)]
#Make a SCALED expression matrix and remove N.A.s
em_scaled = na.omit(data.frame(t(scale(t(em_symbols)))))
#exporting list
em_list = list(em_annotated_table=em_annotated,
em_symbols_table = em_symbols,
em_scaled_table = em_scaled)
return(em_list)
}
## making the dataframes that use em
em_list = em_maker(em,annotations,ss)
# extracting the dataframes from the list
em_annotated = em_list$em_annotated_table
em_symbols = em_list$em_symbols_table
em_scaled = em_list$em_scaled_table
View(em_annotated)
View(DE_Senes_MtD_vs_Prolif)
View(em_annotated)
master_maker = function(profile_names,em_annotated,de,ss){
## Creating master tables
# merge: em_annotated - de
master = merge(em_annotated, de, by.x = 1, by.y = 0)
#rename row.names to "Emsembl_IDs"
names(master)[1] = "Emsembl_IDs"
#make "gene" names.row
row.names(master) = master[,"gene"]
#Remove rows from master table that have N.A.s
master = na.omit(master)
master = subset(master, p != 0)
#Sort master by p-value
sorted_p.adj=order(master[,"p.adj"], decreasing=FALSE)
master=master[sorted_p.adj,]
#Make a new column in master table for mean expression
master$em_mean=rowMeans(master[,as.vector(ss$SAMPLE)])
#Add a column for -log10p to the master table
master$mlog10p=-log10(master$p)
## Exporting many items in a list
master_list = list(profile=profile_names,
master_table=master)
#return master
return(master_list)
}
master_senes_vs_prolif = master_maker("senes_vs_prolif", em_annotated, DE_Senes_vs_Prolif, ss)
View(master_senes_vs_prolif)
master_senes_mtd_vs_senes = master_maker("senes_mtd_vs_senes", em_annotated,DE_Senes_MtD_vs_Senes, ss)
master_senes_vs_prolif
master_senes_mtd_vs_senes
master_filtered_senes_vs_prolif = master_filtered(master_senes_vs_prolif, em_list, 0.05, 1.0)
master_filtered = function(master_list, em_list, p_threshold, fold_threshold){
master = master_list$master_table
profile = master_list$profile
em_symbols = em_list$em_symbols_table
em_scaled = em_list$em_scaled_table
#Add a column flagging significance to the master table
#Make a subset of master selecting only significant genes
master_sig= subset(master,p.adj < p_threshold & abs(master$log2fold) > fold_threshold)
#master sig up
master_sig_up = subset(master, p.adj < p_threshold & log2fold > fold_threshold)
#master sig down
master_sig_down = subset(master, p.adj < p_threshold & log2fold < -(fold_threshold))
#master non sig
master_non_sig = subset(master, p.adj > p_threshold | (log2fold < fold_threshold & log2fold > -fold_threshold))
#Vector with significant genes
sig_genes = master_sig[,"gene"]
#Make expression tables of significant genes only
em_symbols_sig = em_symbols[sig_genes,]
#Similar table for SCALED expression values
em_scaled_sig = em_scaled[sig_genes,]
## Exporting many items in a list
filtered_list = list(profile=profile,
master_sig_table = master_sig,
sig_genes_vector = sig_genes,
master_sig_up_table = master_sig_up,
master_sig_down_table = master_sig_down,
master_non_sig_table = master_non_sig,
em_symbols_sig_table = em_symbols_sig,
em_scaled_sig_table = em_scaled_sig)
## returning filtered_list
return(filtered_list)
}
master_filtered_senes_vs_prolif = master_filtered(master_senes_vs_prolif, em_list, 0.05, 1.0)
View(master_filtered_senes_vs_prolif)
################################################################################
#                                THEMES                                        #
################################################################################
#volcano & MA
theme_volcano = theme(
plot.title = element_text(size=30, hjust = 0.5),
axis.text.x = element_text(size=16),
axis.text.y = element_text(size=16),
axis.title.x = element_text(size=25),
axis.title.y = element_text(size=25),
legend.position = c(.95, .95),
legend.justification = c("right", "top"),
legend.box.just = "right",
legend.box.background = element_rect(),
legend.margin = margin(6, 6, 6, 6),
panel.grid.major = element_line(colour="grey85"),
panel.grid.minor = element_blank(),
panel.background = element_rect(colour = "black",
fill="white") )
#barplot
theme_barplot = theme(
plot.title = element_text(size=30, hjust = 0.5),
axis.text.x = element_text(size=16),
axis.text.y = element_text(size=16),
axis.title.x = element_text(size=25),
axis.title.y = element_text(size=25),
legend.position = "none",
legend.justification = c("right", "top"),
legend.box.just = "right",
legend.box.background = element_rect(),
legend.margin = margin(6, 6, 6, 6),
panel.grid.major = element_line(colour="grey85"),
panel.grid.minor = element_blank(),
panel.background = element_rect(colour = "black",
fill="white") )
#Expression density
#this theme was copy_pasted from the tutorial (MODIFY)
theme_density=theme(panel.grid = element_blank(),
panel.background = element_blank(),
panel.border = element_rect(colour = "black", fill=NA, size=2),
strip.text.x = element_text(size =16, family="Arial", face="bold", vjust=1),
panel.spacing = unit(1, "lines"),
legend.position = "none",
axis.text.x = element_text(size=16),
axis.text.y = element_text(size=16),
axis.title.x = element_text(size=25),
axis.title.y = element_text(size=25))
#FACET boxplot
# erase this one - not decided
theme_single_boxplot =theme(panel.grid = element_blank(),
panel.background = element_blank(),
panel.border = element_rect(colour = "black", fill=NA, size=2),
strip.text.x = element_text(size =16, family="Arial", face="bold", vjust=1),
panel.spacing = unit(1, "lines"),
legend.position = "none",
axis.text.x = element_text(size=16),
axis.text.y = element_text(size=16),
axis.title.x = element_text(size=25),
axis.title.y = element_text(size=25))
theme_facet_boxplot = theme(legend.title = element_blank(),
axis.text.x = element_blank(),
panel.grid.major = element_blank(),
panel.grid.minor = element_blank(),
plot.title = element_text(size=25),
axis.text.y = element_text(size=16),
axis.title.x = element_text(size=25),
axis.title.y = element_text(size=25))
knit_with_parameters("~/Documents/GitHub/SubsetMask/software/Tutorial.Rmd")
?is.null
library(ggplot2)
library(Seurat)
?png
source("~/Documents/GitHub/SubsetMask/software/export.images/main-export.images.R", echo=TRUE)
check_missing_images <- function(seurat.object, fov.names) {
missing.images <- setdiff(fov.names, names(seurat.object@images))
if (length(missing.images) > 0) {
stop(paste(
"These image names are not present in the Seurat object:",
paste(missing.images, collapse = ", ")
))
}
message("All provided image names are present in the Seurat object.")
}
source("~/Documents/GitHub/SubsetMask/software/export.images/test-export_images.R")
rm(export.images)
export_images <- function(seurat.object, dir.out, fov.names = NULL, ...) {
#' Arguments
#' seurat.object: seurat object WITH polygons/segmentation
#' dir.out: output directory
#' fov.names: vector of image names in the "images" slot of the seurat object, if NULL use all images present
#' ... :  additional arguments to pass to the ImageDimPlot function
###--- Checking the fov.names argument ---###
if (is.null(fov.names)) {
# use all spatial FOVs present in the object
fov.names <- names(seurat.object@images)
} else {
# Check the validity of provided image names
check_missing_images(seurat.object=seurat.object, fov.names=fov.names)
}
###--- Exporting images ---###
for (image_name in fov.names) {
# Generate the image
plot.fov <- ImageDimPlot(object = seurat.object,
fov = image_name,
boundaries = "segmentation",
border.size = 0.01,
border.color = "black",
flip_xy = F,
...) +
scale_y_continuous(expand = c(0, 0)) +
scale_x_continuous(expand = c(0, 0)) +
theme_void() +
NoLegend()
# Export the image
png(file.path(dir.out, paste0(image_name, ".png")),
width = 3400, height = 4250, units = "px", res = 300, bg="white")
plot.fov
dev.off()
message(paste("Image", image_name, "exported to", image_dir))
}
}
dirname(rstudioapi::getActiveDocumentContext()$path)
system("ls -l")
output <- system("ls -l", intern = TRUE)
print(output)
system(pwd)
system(pwd())
system("pwd")
erase <- system("pwd")
erase
erase <- system("pwd", intern = T)
erase
system2("pwd", intern=T)
erase <- system("pwd", intern = T)
normalizePath(sys.frames()[[1]]$ofile)
system("dirname $(realpath my_script.R)", intern = TRUE)
args <- commandArgs(trailingOnly = FALSE)
script_path <- sub("--file=", "", args[grep("--file=", args)])
rm(output)
rm(script_path)
rm(args)
reticulate::repl_python()
getwd()
setwd("/Users/robin/Documents/GitHub/SubsetMask/test")
meta <- read.csv("slide_1_metadata")
meta <- read.csv("slide_1_metadata.csv")
View(meta)
meta <- read.csv("slide_1_metadata.csv", row.names = 1, header = T)
unique(meta$Run_Tissue_name)
meta$slide_ID_numeric
meta$slide <- paste0("slide_", meta$slide_ID_numeric)
meta$slide
meta[["slide_1"]]
meta[["slide"]]
meta$cell_id
meta$cell_ID
meta[,c("cell_id","cell_ID")]
image_col <- "slide"
unique(meta[[image_col]])
meta[["slide_1"]]$cell_ID
meta[,"slide"]$cell_ID
meta[["slide"]][["slide_1"]]
meta[["slide"]]
meta["slide"]
meta %>%
filter(!!sym(image_col) == "slide_1")
library(dplyr)
meta %>%
filter(!!sym(image_col) == "slide_1")
image_cells <- meta %>%
filter(!!sym(image_col) == "slide_1") %>%
select(cell_id)
image_cells
image_cells <- meta %>%
filter(!!sym(image_col) == "slide_1") %>%
select(cell_id) %>%
unlist()
image_cells
image_cells <- meta %>%
filter(!!sym(image_col) == "slide_1") %>%
row.names()
image_cells
spatial_points_list <- list()
for (image in unique(meta[[image_col]])){
# get cell names for the desired fov/image
image_cells <- meta %>%
filter(!!sym(image_col) == image) %>%
row.names()
# get the coordinates from the metadata
cell_coordinates <- meta[image_cells, c("x_slide_mm", "y_slide_mm")]
# convert coordinates to SpatialPoints
image_spatial_points <- cell_coordinates %>%
as.matrix() %>%
SpatialPoints()
# assign the SpatialPoints object to the list
spatial_points_list[[image]] <- image_spatial_points
}
install.packages("SpatialPoints")
install.packages("sp")
library(dplyr)
library(sp)
library(tools)
install.packages("argpase")
install.packages("argparse")
# Load argparse package
library(argparse)
# List to store SpatialPoints objects for each image
spatial_points_list <- list()
for (image in unique(meta[[image_col]])){
# get cell names for the desired fov/image
image_cells <- meta %>%
filter(!!sym(image_col) == image) %>%
row.names()
# get the coordinates from the metadata
cell_coordinates <- meta[image_cells, c("x_slide_mm", "y_slide_mm")]
# convert coordinates to SpatialPoints
image_spatial_points <- cell_coordinates %>%
as.matrix() %>%
SpatialPoints()
# assign the SpatialPoints object to the list
spatial_points_list[[image]] <- image_spatial_points
}
spatial_points_list[[image]]
plot(spatial_points_list[[image]] )
processed_images_dir <- "~/GitHub/SubsetMask/test"
# Create a list to store SpatialPolygons objects
spatial_polygons_list <- list()
for (image in unique(meta[[image_col]])) {
# get corrdinated folder for iamge
image_coords_dir <- file.path(processed_images_dir, image, "coordinates")
image_coords <- list.files(image_coords_dir, full.names = TRUE, recursive=F)
# Loop through each file and create SpatialPolygons
for (file in image_coords) {
# name
file_name <- file_path_sans_ext(basename(file))
# Read the coordinates from the CSV file
coords_df <- read.csv(file)
# Create the SpatialPolygons object using the coordinates
coords <- as.matrix(coords_df)
polygon <- Polygon(coords)
spatial_polygon <- Polygons(list(polygon), ID = file_name)
spatial_polygon_object <- SpatialPolygons(list(spatial_polygon))
# assigning the polygon object to the mask.polygons list
spatial_polygons_list[[image]][[file_name]] <- spatial_polygon_object
}
}
plot(spatial_polygon_object)
spatial_polygon_object
spatial_polygons_list
getwd()
processed_images_dir <- "/Users/robin/Documents/GitHub/SubsetMask/test"
# Create a list to store SpatialPolygons objects
spatial_polygons_list <- list()
for (image in unique(meta[[image_col]])) {
# get corrdinated folder for iamge
image_coords_dir <- file.path(processed_images_dir, image, "coordinates")
image_coords <- list.files(image_coords_dir, full.names = TRUE, recursive=F)
# Loop through each file and create SpatialPolygons
for (file in image_coords) {
# name
file_name <- file_path_sans_ext(basename(file))
# Read the coordinates from the CSV file
coords_df <- read.csv(file)
# Create the SpatialPolygons object using the coordinates
coords <- as.matrix(coords_df)
polygon <- Polygon(coords)
spatial_polygon <- Polygons(list(polygon), ID = file_name)
spatial_polygon_object <- SpatialPolygons(list(spatial_polygon))
# assigning the polygon object to the mask.polygons list
spatial_polygons_list[[image]][[file_name]] <- spatial_polygon_object
}
}
spatial_polygon_object
plot(spatial_polygon_object)
plot(spatial_polygon_list$slide_1$label1)
plot(spatial_polygon_list$slide_1$label_1)
spatial_polygons_list[[image]]
spatial_polygons_list
spatial_points_list$slide_1$label1
View(spatial_polygons_list)
plot(spatial_polygon_list$slide_1)
plot(spatial_polygons_list$slide_1)
plot(spatial_polygons_list$slide_1$label1)
plot(spatial_polygons_list$slide_1$label2)
# empty list to store the points inside the region masks
overlap_points_list <- list()
# loop to check if the points are inside the polygon
for (image in unique(meta[[image_col]])){
# image spatial points
points <- spatial_points_list[[image]]
for (mask_name in names(spatial_polygons_list[[image]])){
mask <- spatial_polygons_list[[image]][[mask_name]]
inside_polygon <- !is.na(over(points, mask))
inside_polygon_df <- data.frame(inside_polygon)
names(inside_polygon_df)[1] <- "inside"
# Get the row names of points that are inside the polygon
inside_polygon_cells <- row.names(subset(inside_polygon_df, inside == TRUE))
# remove "coords" from the mask_name
#mask_name <- gsub("-coords", "", mask_name)
# removed the image name from the inside_points object lists
# i.e. "agranular_insula" instead of "s1055ant_bs1-agranular_insula"
# remove the image name from the mask name (DID IT)
#mask_name <- gsub(paste0(image,"-"), "", mask_name)
overlap_points_list[[image]][[mask_name]] <- inside_polygon_cells
}
}
overlap_points_list
new_col = sample
metadata[[new_col]] <- "not_assigned"
meta[[new_col]] <- "not_assigned"
new_col
ann_col = "sample"
# create a column in the metadata object to store the region labels and set "not assigned" by default
meta[[ann_col]] <- "not_assigned"
# image names inside the overlap_points_list
image_names <- names(overlap_points_list)
image_names
# get all the names/barcodes of cells from the metadata
all_cells <- rownames(metadata)
for (image in image_names){
image_overlap_points <- overlap_points_list[[image]]
section_names <- names(image_overlap_points)
for (section in section_names){
# assign the region name to the cells in the region
section_cells <- image_overlap_points[[section]]
# assign "section" in the metadata (ann_col) to the cells in section_cells
meta[all_cells %in% section_cells, ann_col] <- section
}
# main processing loop
for (image in image_names){
image_overlap_points <- overlap_points_list[[image]]
section_names <- names(image_overlap_points)
for (section in section_names){
# assign the region name to the cells in the region
section_cells <- image_overlap_points[[section]]
# assign "section" in the metadata (ann_col) to the cells in section_cells
meta[all_cells %in% section_cells, ann_col] <- section
}
}
print("Number of cells assigned to each section")
print(table(meta[ann_col], useNA="always"))
}
# create a column in the metadata object to store the region labels and set "not assigned" by default
meta[[ann_col]] <- "not_assigned"
# image names inside the overlap_points_list
image_names <- names(overlap_points_list)
# get all the names/barcodes of cells from the metadata
all_cells <- rownames(meta)
# main processing loop
for (image in image_names){
image_overlap_points <- overlap_points_list[[image]]
section_names <- names(image_overlap_points)
for (section in section_names){
# assign the region name to the cells in the region
section_cells <- image_overlap_points[[section]]
# assign "section" in the metadata (ann_col) to the cells in section_cells
meta[all_cells %in% section_cells, ann_col] <- section
}
}
print("Number of cells assigned to each section")
print(table(meta[ann_col], useNA="always"))
gwtwd()
getwd()
out_path = "/Users/robin/Documents/GitHub/SubsetMask/test/metadata_annotated.csv"
write.csv(meta, out_path, row.names = TRUE)
cat("Annotated metadata saved successfully at", out_path, "\n")
ann_meta <- read.csv(out_path, row.names = 1, header = T)
View(ann_meta)
unique(ann_meta$sample)
View(ann_meta)
meta <- read.csv(metadata_path, row.names = 1, header = T)
#erase this when done
setwd("/Users/robin/Documents/GitHub/SubsetMask/test")
meta <- read.csv("slide_1_metadata.csv", row.names = 1, header = T)
meta$slide <- paste0("slide_", meta$slide_ID_numeric)
images_col <- "slide"
write.csv(meta, "slide_1_metadata_og.csv", row.names = TRUE)
names(meta)
